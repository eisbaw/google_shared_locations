/////////////////////////////////////////////////////////////////
/////////////////// Взаимодействие с БД /////////////////////////
var Result = require('./Result');
var Errors = require('./Errors');
var Common = require('./Common');

//tmp
//var uuid = require('node-uuid');

var pg = require('pg');

var Dao = function(connStr) {
    this.db = null;
    this.maxReconnCount = 1;
    this.connStr = connStr;
    this.connecting = false;
    this.sessions = {};
    this.sid = 100;
    this.queries = 0;
}

function openSession(self) {
    var s = {
        noConnection : false,
        reconnCount : 0,
        connecting : false
    }

    self.sid++;
    /*
     if(self.sid>1000){
     self.sid = 0;
     }
     */
    self.sessions[self.sid] = s;

    return self.sid;
}

function closeSession(self, sid) {
    delete self.sessions[sid];
}

Dao.prototype.queryArray = function(text, par, h) {
    var self = this;
    var ret = new Result(h, arguments, 'Dao.prototype.queryArray');

    var parArr = Common.check_array(par);

    if(!parArr || (0==parArr.length) || !(parArr instanceof Array)){
        ret.error(Errors.database.bad_array);
        return;
    }

    var session = openSession(self);

    var Join = require('join');
    var join = Join();

    for(var i in parArr){
        querySingleSessioned(self, text, par[i], session, join.add());
    }

    join.when(function(){
        ret.result(arguments);
        closeSession(self, session);
    });
}

// Dao.prototype.queryArraySync - плохая идея

var querySingleSessioned = function(self, text, par, session, h) {
    var ret = new Result(h, arguments, 'querySingleSessioned');

    //console.log( session + ': ' );
    //console.log( self.sessions );

    if(self.sessions[session].noConnection){
        //console.log( session + ': Подключение к БД не удалось на предыдущих шагах' );
        ret.error(Errors.database.skipped, 'Подключение к БД не удалось на предыдущих шагах');
        return;
    }

    var reconnCount = self.sessions[session].reconnCount;
    var connecting = self.sessions[session].connecting;

    if(!self.db) {
        // (0<reconnCount) - значит это тот процесс который захватил на себя обязанности по подключению
        if( !self.connecting && !connecting ){
            //console.log('db_sid: '+session+' d1-1');
            self.connecting = true;
            self.sessions[session].connecting = true;
            pg.connect(self.connStr, ret.checkError(Errors.database.reconnect, connected, reconnect));
        } else {
            //console.log('db_sid: '+session+' d1-2');
            setTimeout(function(){
                querySingleSessioned(self, text, par, session, h);
            }, 100);
        }
    } else {
        //console.log('db_sid: '+session+' d2');

        // молча отсыхает падла, потому:
        if(false==self.db.connection.stream.readable){
            //console.log('db_sid: '+session+' O T C O X JI O');
            self.db = null;
            querySingleSessioned(self, text, par, session, h);
        } else {
            query();
        }
    }

    function reconnect(e){
        self.connecting = false;
        self.sessions[session].connecting = false;

        //console.log('db_sid: '+session+' d3');
        if(reconnCount>self.maxReconnCount) {
            //console.log('db_sid: '+session+' d3-1');
            self.sessions[session].noConnection = true; // если не удалось подключится к БД, отбиваем все остальные запросы в этой сессии
            ret.error(Errors.database.connect, e);
        } else {
            //console.log('db_sid: '+session+' d3-2');
            self.sessions[session].reconnCount++;
            querySingleSessioned(self, text, par, session, h);
        }
    }

    function connected(client) {
        self.connecting = false;
        self.sessions[session].connecting = false;

        self.db = client;
        self.db.query('SET client_encoding TO \'utf8\'', ret.checkError(Errors.database.set_encoding, query));
    }

    function query(){
        self.queries++;
        //console.log('db_sid: '+session+' d5 - query');

        //console.log(self.db);

        self.db.query(text, [ par ], ret.checkError(Errors.database.query, query_ok, query_fail));

        /*self.db.query(text, [ par ], function(e,o){
         //console.log(e||o);

         if(o) query_ok(o);
         else query_fail(e);
         });*/

        function query_ok(o){
            self.queries--;

            //console.log('db_sid: '+session+' done - query_ok');
            //console.log(o);

            //console.log('db_sid: '+session+' d6');
            if(0==text.toLowerCase().indexOf('select ')){ // это селект
                //console.log('db_sid: '+session+' d6-1');
                if(0==o.rows.length){
                    //console.log('db_sid: '+session+' d6-2');
                    //console.log(text);
                    //console.log(par);
                    //ret.checkError(Errors.database.empty)(new Error('пустая выборка'));
                    ret.error(Errors.database.empty, [text, par]);
                    return;
                }

                //console.log('db_sid: '+session+' d6-3');
                //TODO как реагировать если выборка не однозначна
                if(1<o.rows.length){
                    //console.log('db_sid: '+session+' d6-4');
                    //Errors.database('не однозначные данные', true);
                    //console.log('не однозначные данные');
                }

                //console.log('db_sid: '+session+' d6-5');

                ret.result(o.rows[0]);
            } else { // update, insert, etc
                ret.result(o.rows[0]);
            }
        }

        //console.log(self.queries);

        function query_fail(e){
            self.queries--;

            //console.log('db_sid: '+session+' d7 - query_fail');
            // выполняем тестовый запрос чтобы узнать проблема с запросом или с коннектом
            var tq = 'SET client_encoding TO \'utf8\'';
            self.db.query(tq, function(e1,o){
                if(e1) { // ошибка с коннектом
                    self.db = null;
                    self.sessions[session].reconnCount++;
                    querySingleSessioned(self, text, par, session, h);
                    return;
                } else {
                    ret.error(Errors.inner, e);
                    return;
                }
            });
        }
    }
}

// может вернуть эррор
Dao.prototype.querySingle = function(text, par, h) {
    var self = this;
    var ret = new Result(h, arguments, 'Dao.prototype.querySingle');

    var session = openSession(self);
    querySingleSessioned(self, text, par, session, function(e,o){
        closeSession(self, session);
        //ret.checkError(Errors.inner, ret.result, ret.error)(e,o);
        ret.checkError(Errors.inner)(e,o);
    });
}

Dao.prototype.appendMethods = function(carrier, definition) {
    Dao.prototype[carrier] = {};
    var f = new Function('dao', 'req', 'func',
        'return function(param, cb) { return dao[func](req, param, cb); }'
    );
    for(var i in definition){
        Dao.prototype[carrier][i] = f(this, definition[i], 'querySingle');
        Dao.prototype[carrier][i+'Array'] = f(this, definition[i], 'queryArray');
    }
}

/////////////////// Взаимодействие с БД /////////////////////////
/////////////////////////////////////////////////////////////////

module.exports = Dao;