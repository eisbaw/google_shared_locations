var Memcached = require('memcached');

var Result = require('./Result');
var Errors = require('./Errors');

//TODO написать тест кейсы

////////////////////////////////////////////////////////////
///////////////////// Constructor //////////////////////////

var Cache = function(connection) {
    this.cache = new Memcached();
    this.connected = false;
    this.connecting = false;
    this.connection = connection;
    this.retry = 2;
    this.retry_delay = 10; // msec
    this.paralell = 0;
    this.paralell_max = 10;
}

///////////////////// Constructor //////////////////////////
////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////
///////////////////// Private methods //////////////////////

function f_connect(self, h){
    if(self.connected){
        h(null, true);
        return;
    }

    if(self.connecting){
        return setTimeout(function(){
            return f_connect(self, h);
        }, 100);
    }

    //обеспечиваем паралеллизм и обходим переполение коннектов в пулле
    //https://github.com/3rd-Eden/node-memcached/issues/54
    self.one_done = false;

    self.connecting = true;
    self.cache.connect(self.connection, function(e,o){
        if(e){
            h(e);
            return;
        }

        h(null, 'connected to cahce!');

        wait_cache_operation_done();

        // а тут задерживаем обработку появления коннекта остальными процессами
        function wait_cache_operation_done(){
            if(!self.one_done){
                setTimeout(function(){
                    wait_cache_operation_done();
                }, 100);
            } else {
                // разрешаем остальным процессам воспользоваться коннектом
                self.connecting = false;
                self.connected = true;
            }
        }
    });
}

///////////////////// Private methods //////////////////////
////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////
///////////////////// Public methods ///////////////////////

Cache.prototype.read_array = function(arr_idx, h) {
    var self = this;

    var ret = new Result(h, arguments, 'Cache.prototype.read_array');

    if(!arr_idx || (0==arr_idx.length) || !(arr_idx instanceof Array)){
        ret.error(Errors.cache.bad_array);
        return;
    }

    var Join = require('join');
    var join = Join();

    for(var i in arr_idx){
        self.read(arr_idx[i], join.add());
    }

    join.when(function(){
        ret.result(arguments);
    });
}

Cache.prototype.write_array = function(arr, life_time, h) {
    var self = this;

    //console.log(JSON.stringify(arr, null, '\t'));

    var ret = new Result(h, arguments, 'Cache.prototype.write_array');

    if(!arr || (0==arr.length) || !(arr instanceof Array)){
        ret.error(Errors.cache.bad_array);
        return;
    }

    //self.write(arr[0][0], arr[0][1], life_time, ret.checkError(Errors.inner, f_first_writed));

    var Join = require('join');
    var join = Join();

    for(var i=0; i<arr.length; i++){
        self.write(arr[i][0], arr[i][1], life_time, join.add());
    }

    join.when(function(){
        var all_ok = true;
        for(var i in arguments){
            if(arguments[i][0]){
                all_ok = false;
                break;
            }
        }
        if(!all_ok){
            ret.error(Errors.cache.write_array);
        } else {
            ret.result('all cached');
        }
    });

}

// по идее нельзя хранить булы
Cache.prototype.write = function(idx, o, life_time, h, k) {
    var self = this;

    var ret = new Result(h, arguments, 'Cache.prototype.write');

    if(!k) k = 0;
    if(k>self.retry){
        ret.error(Errors.cache.read, self.error);
        delete self.error;
        return;
    }

    // мемкакед подлипает зараза, если передать undefined
    if(!idx){
        ret.error(Errors.cache.wrong_cell, [idx, life_time, o]);
        return;
    }

    if(undefined==o){
        ret.error(Errors.cache.wrong_data, [idx, life_time, o]);
        return;
    }

    if(!life_time || (0==life_time)){
        ret.error(Errors.cache.life_time, [idx, life_time, o]);
        return;
    }

    f_connect(self, ret.checkError(Errors.cache.connect, f_connected));

    function f_connected(){
        if(self.paralell<self.paralell_max){
            self.paralell++;
            self.cache.set(idx, o, life_time, ret.checkError(Errors.cache.write, f_writed, f_reconnect));
        } else {
            setTimeout(function(){
                f_connected();
            }, 100);
        }
    }

    function f_writed(r){
        self.paralell--;
        self.one_done = true;
        if(false==r){
            ret.error(Errors.cache.not_writed, idx);
            return;
        }

        ret.result(r);
    }

    function f_reconnect(error){
        // можно залогировать error
        self.connected = false;
        self.error = error;

        setTimeout(function(){
            self.write(idx, o, life_time, h, ++k);
        }, self.retry_delay);
    }
}

Cache.prototype.read = function(idx, h, k) {
    var self = this;

    var ret = new Result(h, arguments, 'Cache.prototype.read');

    if(!k) k = 0;
    if(k>self.retry){
        ret.error(Errors.cache.read, self.error);
        delete self.error;
        return;
    }

    // мемкакед подлипает зараза, если передать undefined
    if(!idx){
        ret.error(Errors.cache.wrong_cell, idx);
        return;
    }

    f_connect(self, ret.checkError(Errors.cache.connect, f_connected));

    function f_connected(){
        if(self.paralell<self.paralell_max){
            self.paralell++;
            self.cache.get(idx, ret.checkError(Errors.cache.read, f_readed, f_reconnect));
        } else {
            setTimeout(function(){
                f_connected();
            }, 100);
        }
    }

    function f_readed(r){
        self.paralell--;
        self.one_done = true;
        if(false==r){
            ret.error(Errors.cache.empty, idx);
            return;
        }

        ret.result(r);
    }

    function f_reconnect(error){
        // можно залогировать error
        self.connected = false;
        self.error = error;

        setTimeout(function(){
            self.read(idx, h, ++k);
        }, self.retry_delay);
    }
}

///////////////////// Public methods ///////////////////////
////////////////////////////////////////////////////////////

module.exports = Cache;